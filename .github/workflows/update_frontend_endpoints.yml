name: Update Frontend Endpoints on Backend Deploy

on:
  push:
    branches:
      - master
    paths:
      - 'services/**'

env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID_FRONTEND }}
  VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
  FRONTEND_PROJECT_NAME: 'frontend-tester'

jobs:
  update-and-redeploy:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Vercel CLI and jq
        run: |
          npm install -g vercel
          sudo apt-get update && sudo apt-get install -y jq

      - name: Identify Changed Backend Services
        id: changed_services
        run: |
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
          echo "Files changed in this push: $CHANGED_FILES"
          CHANGED_SERVICES=$(echo "$CHANGED_FILES" | grep 'services/' | awk -F'/' '{print $2}' | sort -u)
          if [ -z "$CHANGED_SERVICES" ]; then
            echo "No backend services were changed. Exiting."
            exit 0
          fi
          echo "Backend services changed: $CHANGED_SERVICES"
          echo "services=${CHANGED_SERVICES}" >> $GITHUB_OUTPUT

      - name: Update Vercel Environment Variables
        if: steps.changed_services.outputs.services
        run: |
          for SERVICE_DIR in ${{ steps.changed_services.outputs.services }}; do
            echo "Processing service: $SERVICE_DIR"
            VERCEL_PROJECT_NAME=$SERVICE_DIR
            ENV_VAR_NAME=""
            case $SERVICE_DIR in
              "servico-agentes-ia") ENV_VAR_NAME="NEXT_PUBLIC_AI_API_URL" ;;
              "servico-busca") ENV_VAR_NAME="NEXT_PUBLIC_SEARCH_API_URL" ;;
              "servico-healthcheck") continue ;;
              "servico-lojas") ENV_VAR_NAME="NEXT_PUBLIC_STORES_API_URL" ;;
              "servico-monitoramento") ENV_VAR_NAME="NEXT_PUBLIC_MONITORING_API_URL" ;;
              "servico-ofertas") ENV_VAR_NAME="NEXT_PUBLIC_OFFERS_API_URL" ;;
              "servico-produtos") ENV_VAR_NAME="NEXT_PUBLIC_PRODUCTS_API_URL" ;;
              "servico-usuarios") ENV_VAR_NAME="NEXT_PUBLIC_USERS_API_URL" ;;
              *) echo "Warning: No mapping for $SERVICE_DIR." && continue ;;
            esac
            
            echo "Fetching URL for $VERCEL_PROJECT_NAME..."
                      # Get the URL of the latest deployment with status 'Ready'
                      NEW_URL=$(vercel ls $VERCEL_PROJECT_NAME --prod --token=${{ secrets.VERCEL_TOKEN }} | awk '/Ready/ && /https:\/\// {for(i=1;i<=NF;i++) if ($i ~ /^https:\/\//) {print $i; exit}}')
            if [[ -z "$NEW_URL" ]]; then
              echo "Error: Could not parse deployment URL for $VERCEL_PROJECT_NAME. Skipping."
              continue
            fi
            
            echo "Found new URL: $NEW_URL"
            vercel env rm $ENV_VAR_NAME production -y --token=${{ secrets.VERCEL_TOKEN }} || true
            echo $NEW_URL | vercel env add $ENV_VAR_NAME production --token=${{ secrets.VERCEL_TOKEN }}
            echo "---"
          done

      - name: Trigger Redeployment of Frontend
        if: steps.changed_services.outputs.services
        run: |
          echo "Triggering a new production deployment for $FRONTEND_PROJECT_NAME..."
          # Get the URL of the latest deployment with status 'Ready'
          DEPLOYMENT_URL=$(vercel ls $FRONTEND_PROJECT_NAME --prod --token=${{ secrets.VERCEL_TOKEN }} | awk '/Ready/ && /https:\/\// {for(i=1;i<=NF;i++) if ($i ~ /^https:\/\//) {print $i; exit}}')
          
          if [[ -z "$DEPLOYMENT_URL" ]]; then
            echo "Error: Could not parse deployment URL for $FRONTEND_PROJECT_NAME to redeploy."
            exit 1
          fi

          echo "Redeploying production deployment: $DEPLOYMENT_URL"
          vercel redeploy $DEPLOYMENT_URL --target production --token=${{ secrets.VERCEL_TOKEN }}