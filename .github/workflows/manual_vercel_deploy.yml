name: Manual Vercel Deploy and Frontend Update

on:
  push:
    branches:
      - master
    paths:
      - 'services/**' # Trigger when any service changes

env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID_FRONTEND: ${{ secrets.VERCEL_PROJECT_ID_FRONTEND }} # ID of the frontend-tester project
  VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
  FRONTEND_PROJECT_NAME: 'frontend-tester'

jobs:
  deploy-services-and-update-frontend:
    runs-on: ubuntu-latest
    environment: production # Use production environment for secrets

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Get full history for git diff

      - name: Install Vercel CLI and jq
        run: |
          npm install -g vercel
          sudo apt-get update && sudo apt-get install -y jq

      - name: Identify Changed Backend Services
        id: changed_services
        run: |
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
          echo "Arquivos alterados neste push: $CHANGED_FILES"
          CHANGED_SERVICES=$(echo "$CHANGED_FILES" | grep 'services/' | awk -F'/' '{print $2}' | sort -u)
          if [ -z "$CHANGED_SERVICES" ]; then
            echo "Nenhum serviço de backend foi alterado. Saindo."
            exit 0
          fi
          echo "Serviços de backend alterados: $CHANGED_SERVICES"
          echo "services=${CHANGED_SERVICES}" >> $GITHUB_OUTPUT

      - name: Deploy Changed Services and Update Frontend Endpoints
        if: steps.changed_services.outputs.services # Only run if services changed
        run: |
          declare -A SERVICE_URLS # Array associativo para armazenar URLs de serviço

          for SERVICE_DIR in ${{ steps.changed_services.outputs.services }}; do
            echo "Processando serviço: $SERVICE_DIR"
            VERCEL_PROJECT_NAME=$SERVICE_DIR # Assumindo que o nome do projeto Vercel corresponde ao nome do diretório
            SERVICE_PATH="services/$SERVICE_DIR"
            ENV_VAR_NAME=""

            case $SERVICE_DIR in
              "servico-agentes-ia") ENV_VAR_NAME="NEXT_PUBLIC_AI_API_URL" ;;# Assumindo que este é o mapeamento correto
              "servico-busca") ENV_VAR_NAME="NEXT_PUBLIC_SEARCH_API_URL" ;;
              "servico-healthcheck") continue ;;# O serviço Healthcheck pode não precisar de uma URL pública
              "servico-lojas") ENV_VAR_NAME="NEXT_PUBLIC_STORES_API_URL" ;;
              "servico-monitoramento") ENV_VAR_NAME="NEXT_PUBLIC_MONITORING_API_URL" ;;
              "servico-ofertas") ENV_VAR_NAME="NEXT_PUBLIC_OFFERS_API_URL" ;;
              "servico-produtos") ENV_VAR_NAME="NEXT_PUBLIC_PRODUCTS_API_URL" ;;
              "servico-usuarios") ENV_VAR_NAME="NEXT_PUBLIC_USERS_API_URL" ;;
              *) echo "Aviso: Nenhum mapeamento para $SERVICE_DIR." && continue ;;# Pular se não houver mapeamento
            esac

            echo "Implantando $SERVICE_DIR no Vercel..."
            # Implantar o serviço e capturar a URL
            # Usar --project para vincular ao projeto Vercel existente pelo nome
            DEPLOY_OUTPUT=$(vercel deploy "$SERVICE_PATH" --prod --token=${{ secrets.VERCEL_TOKEN }} --project "$VERCEL_PROJECT_NAME" 2>&1)
            DEPLOY_EXIT_CODE=$?
            echo "$DEPLOY_OUTPUT" # Imprimir saída de implantação para depuração

            if [[ $DEPLOY_EXIT_CODE -ne 0 ]]; then
              echo "Erro: A implantação Vercel para $SERVICE_DIR falhou com o código de saída $DEPLOY_EXIT_CODE."
              exit 1 # Falhar o workflow
            fi

            # Extrair a URL da saída de implantação (geralmente a última linha)
            NEW_SERVICE_URL=$(echo "$DEPLOY_OUTPUT" | tail -n 1)
            
            # Validação básica para URL
            if [[ ! "$NEW_SERVICE_URL" =~ ^https?:// ]]; then
              echo "Erro: Não foi possível extrair uma URL válida da saída de implantação Vercel para $SERVICE_DIR."
              exit 1
            fi

            echo "Implantado $SERVICE_DIR em: $NEW_SERVICE_URL"
            SERVICE_URLS[$ENV_VAR_NAME]=$NEW_SERVICE_URL # Armazenar URL para atualização posterior

            echo "Atualizando Variável de Ambiente Vercel $ENV_VAR_NAME para o frontend..."
            # Remover variável de ambiente existente (se houver) e adicionar a nova
            vercel env rm "$ENV_VAR_NAME" production -y --token=${{ secrets.VERCEL_TOKEN }} || true # Usar || true para ignorar se não encontrado
            echo "$NEW_SERVICE_URL" | vercel env add "$ENV_VAR_NAME" production --token=${{ secrets.VERCEL_TOKEN }}
            echo "---"
          done

          # Disparar Reimplementação do Frontend
          echo "Disparando uma nova implantação de produção para $FRONTEND_PROJECT_NAME..."
          # Obter a URL da última implantação READY do frontend para reimplantá-la
          # Isso assume que o projeto frontend também está vinculado e tem implantações
          FRONTEND_DEPLOYMENT_URL=$(vercel ls $FRONTEND_PROJECT_NAME --prod --token=${{ secrets.VERCEL_TOKEN }} | awk '/Ready/ {print $2; exit}')

          if [[ -z "$FRONTEND_DEPLOYMENT_URL" ]]; then
            echo "Erro: Não foi possível encontrar uma URL de implantação pronta para $FRONTEND_PROJECT_NAME para reimplantar."
            exit 1
          fi

          echo "Reimplantando implantação de produção: $FRONTEND_DEPLOYMENT_URL"
          REDEPLOY_OUTPUT=$(vercel redeploy "$FRONTEND_DEPLOYMENT_URL" --target production --token=${{ secrets.VERCEL_TOKEN }} 2>&1)
          REDEPLOY_EXIT_CODE=$?
          echo "$REDEPLOY_OUTPUT" # Imprimir saída de reimplementação para depuração

          if [[ $REDEPLOY_EXIT_CODE -ne 0 ]]; then
            echo "Erro: O comando de reimplementação Vercel para o frontend falhou com o código de saída $REDEPLOY_EXIT_CODE."
            exit 1 # Falhar o workflow
          fi
